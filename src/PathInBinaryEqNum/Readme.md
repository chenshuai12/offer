**二叉树中和为某一值的路径**

> 输入一颗二叉树和一个整数，打印出二叉数中节点值得和为输入整数的所有路径。从树的根节点开始往下一直到叶子结点所经过的节点形成一条路径


> 1.假设找到了其中一条路径，达到叶结点后，由于没有指向父结点的指针，所以必须提前创建一个链表存储前面经过的结点。
> 2.由于是从根结点出发，所以要想到使用前序遍历
> 3.利用链表存储结点，在该结点完成左右子树的路径搜索后（即递归函数结束，返回到其父结点之前），要删除该结点，从而记录别的路径。
> 具体实现：通过前序遍历，从根结点出发，每次在链表中存储遍历到的结点，若到达叶子结点，则根据所有结点的和是否等于输入的整数，判断是否打印输出。在当前结点访问结束后，递归函数将会返回到它的父结点，所以在函数退出之前，要删除链表中的当前结点，以确保返回父结点时，储存的路径刚好是从根结点到父结点。
> 改进：书中的代码是根据所有结点的和是否等于输入的整数，判断是否打印输出。其实没有这个必要，只需要在每次遍历到一个结点时，令目标整数等于自己减去当前结点的值，若到达根结点时，最终的目标整数等于0就可以打印输出。（描述得不是很清楚，就是相当于每个结点的目标整数不同，详见代码）